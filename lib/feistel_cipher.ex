defmodule FeistelCipher do
  @moduledoc """
  Encrypted integer IDs using Feistel cipher.

  ## Basic Usage

  ```elixir
  defmodule MyApp.Repo.Migrations.AddFeistelCipher do
    use Ecto.Migration

    def up, do: FeistelCipher.up_for_functions()
    def down, do: FeistelCipher.down_for_functions()
  end
  ```

  ## With Custom Prefix

  ```elixir
  def up, do: FeistelCipher.up_for_functions(functions_prefix: "private")
  def down, do: FeistelCipher.down_for_functions(functions_prefix: "private")
  ```

  See function documentation for detailed options and examples.
  """

  use Ecto.Migration

  @doc """
  Generates a cryptographically secure random salt for the Feistel cipher.

  Returns a random integer between 0 and 2^31-1.

  ## Example

      salt = FeistelCipher.generate_random_salt()
      FeistelCipher.up_for_functions(functions_salt: salt)
  """
  @spec generate_random_salt() :: non_neg_integer()
  def generate_random_salt do
    <<salt::31, _::1>> = :crypto.strong_rand_bytes(4)
    salt
  end

  @doc """
  Create FeistelCipher functions in the database.

  ## Options

  * `:functions_prefix` - Schema prefix for functions (default: "public"). ⚠️ Cannot be changed after creation.
  * `:functions_salt` - Salt constant for cipher algorithm. A random value is generated by default if not specified. Must be 0 to 2^31-1. ⚠️ Cannot be changed after creation.
  """
  @spec up_for_functions(keyword()) :: :ok
  def up_for_functions(opts \\ []) when is_list(opts) do
    functions_prefix = Keyword.get(opts, :functions_prefix, "public")
    functions_salt = Keyword.get(opts, :functions_salt, generate_random_salt())
    validate_key!(functions_salt, "functions_salt")

    execute("CREATE SCHEMA IF NOT EXISTS #{functions_prefix}")
    execute("CREATE EXTENSION IF NOT EXISTS pgcrypto")

    # Feistel cipher implementation based on https://wiki.postgresql.org/wiki/Pseudo_encrypt
    # Enhanced with key-based HMAC-SHA256 for cryptographic security
    # Algorithm reference: https://www.youtube.com/watch?v=FGhj3CGxl8I

    # bigint is 64 bits, but excluding negative numbers, only 63 bits are usable.
    # Limited to a maximum of 62 bits as it needs to be halved for the operation.
    # Multiplication and operation parameters are all limited to 31 bits.
    # Since 31 bits (half of 62 bits) are multiplied by a 31-bit parameter,
    # the calculation result is also within the 62-bit range, making it safe for bigint.
    execute("""
    CREATE FUNCTION #{functions_prefix}.feistel_cipher(value bigint, bits int, key bigint, rounds int) returns bigint AS $$
      DECLARE
        round      int;
        left_half  bigint;
        right_half bigint;
        temp       bigint;

        half_bits  int    := bits / 2;
        half_mask  bigint := (1::bigint << half_bits) - 1;
        mask       bigint := (1::bigint << bits) - 1;
        hash_bytes bytea;
        hash_int   bigint;

      BEGIN
        IF bits < 2 OR bits > 62 OR bits % 2 = 1 THEN
          RAISE EXCEPTION 'feistel_cipher: bits must be an even number between 2 and 62: %', bits;
        END IF;

        IF key < 0 OR key >= (1::bigint << 31) THEN
          RAISE EXCEPTION 'feistel_cipher: key must be between 0 and 2^31-1: %', key;
        END IF;

        IF value > mask THEN
          RAISE EXCEPTION 'feistel_cipher: value is larger than % bits: %', bits, value;
        END IF;

        IF rounds < 1 OR rounds > 32 THEN
          RAISE EXCEPTION 'feistel_cipher: rounds must be between 1 and 32: %', rounds;
        END IF;

        -- Split value into left and right halves
        left_half  := (value >> half_bits) & half_mask;
        right_half := value & half_mask;

        -- Feistel rounds with HMAC-SHA256 round function
        -- Using cryptographic HMAC makes the cipher resistant to all known attacks
        -- Note: Round number is NOT included in hash to maintain encrypt/decrypt symmetry
        FOR round IN 1..rounds LOOP
          temp       := right_half;
          hash_bytes := hmac(int4send(right_half::int4), int4send(key::int4) || int4send(#{functions_salt}::int4), 'sha256');
          hash_int   := get_byte(hash_bytes, 0)::bigint << 24
                      | get_byte(hash_bytes, 1)::bigint << 16
                      | get_byte(hash_bytes, 2)::bigint << 8
                      | get_byte(hash_bytes, 3)::bigint;
          right_half := left_half # (hash_int & half_mask);
          left_half  := temp;
        END LOOP;

        -- Final swap
        temp       := left_half;
        left_half  := right_half;
        right_half := temp;

        -- Combine halves
        RETURN ((left_half << half_bits) | right_half);
      END;
    $$ LANGUAGE plpgsql strict immutable;
    """)

    execute("""
    CREATE FUNCTION #{functions_prefix}.feistel_column_trigger() RETURNS trigger AS $$
      DECLARE
        -- Trigger parameters
        from_column  text;
        to_column    text;
        time_bits    int;
        time_offset  bigint;
        time_bucket  bigint;
        encrypt_time int;
        data_bits    int;
        key          bigint;
        rounds       int;

        -- From and to values
        from_value     bigint;
        to_value       bigint;

        -- Time-related values
        time_value     bigint;
        time_component bigint;

        -- Data-related values
        data_component bigint;

        -- Temporary values for validation
        decrypted      bigint;
        old_from_value bigint;

      BEGIN
        -- Extract trigger parameters
        from_column  := TG_ARGV[0];
        to_column    := TG_ARGV[1];
        time_bits    := COALESCE(TG_ARGV[2]::int, 0);
        time_offset  := COALESCE(TG_ARGV[3]::bigint, 0);
        time_bucket  := COALESCE(TG_ARGV[4]::bigint, 1);
        encrypt_time := COALESCE(TG_ARGV[5]::int, 0);
        data_bits    := TG_ARGV[6]::int;
        key          := TG_ARGV[7]::bigint;
        rounds       := TG_ARGV[8]::int;

        -- Early return: If from_column is not modified on UPDATE, skip re-encryption.
        -- This allows manual modification of to_column if from_column remains unchanged.
        IF TG_OP = 'UPDATE' THEN
          EXECUTE format('SELECT ($1).%I::bigint, ($2).%I::bigint', from_column, from_column)
          INTO old_from_value, from_value
          USING OLD, NEW;

          IF old_from_value IS NOT DISTINCT FROM from_value THEN
            RETURN NEW;
          END IF;
        ELSE
          -- Get the from_value from the from_column (for INSERT)
          EXECUTE format('SELECT ($1).%I::bigint', from_column)
          INTO from_value
          USING NEW;
        END IF;

        -- Handle NULL case early
        IF from_value IS NULL THEN
          to_value := NULL;
        ELSE
          -- Calculate time component
          -- When time_bits = 0: time_value & 0 = 0, so time_component = 0
          -- and (0 << data_bits) | data_component = data_component (no time prefix)
          time_value := floor((extract(epoch from now()) - time_offset::double precision) / time_bucket::double precision)::bigint;
          time_value := time_value & ((1::bigint << time_bits) - 1);

          IF encrypt_time = 1 AND time_bits > 0 THEN
            time_component := #{functions_prefix}.feistel_cipher(time_value, time_bits, key, rounds);
          ELSE
            time_component := time_value;
          END IF;

          -- Encrypt the data part using feistel cipher
          data_component := #{functions_prefix}.feistel_cipher(from_value, data_bits, key, rounds);

          -- Sanity check: Verify data part encryption is reversible
          decrypted := #{functions_prefix}.feistel_cipher(data_component, data_bits, key, rounds);

          IF decrypted IS DISTINCT FROM from_value THEN
            RAISE EXCEPTION 'feistel_column_trigger: feistel_cipher does not have an inverse (from: %, data_component: %, decrypted: %, data_bits: %, key: %, rounds: %)',
              from_value, data_component, decrypted, data_bits, key, rounds;
          END IF;

          -- Combine: [time_bits | data_bits]
          to_value := (time_component << data_bits) | data_component;
        END IF;

        -- Set the to_value to the to_column in the NEW record
        NEW := jsonb_populate_record(NEW, jsonb_build_object(to_column, to_jsonb(to_value)));

        RETURN NEW;
      END;
    $$ LANGUAGE plpgsql;
    """)
  end

  @doc """
  Drop FeistelCipher functions from the database.

  **Note**: PostgreSQL will automatically prevent this operation if any triggers
  are still using these functions. Drop all triggers first using `down_for_trigger/4`.

  ## Options

  * `:functions_prefix` - Schema prefix where functions are located (default: "public").
  """
  @spec down_for_functions(keyword()) :: :ok
  def down_for_functions(opts \\ []) when is_list(opts) do
    functions_prefix = Keyword.get(opts, :functions_prefix, "public")

    execute("DROP FUNCTION #{functions_prefix}.feistel_cipher(bigint, int, bigint, int)")
    execute("DROP FUNCTION #{functions_prefix}.feistel_column_trigger()")
  end

  @doc """
  Returns SQL to create a trigger that encrypts a `from` column to a `to` column.

  The resulting ID structure is `[time_bits | data_bits]`, where time_bits serve as a
  prefix to cluster rows created in the same time bucket on nearby PostgreSQL pages,
  optimizing incremental backup efficiency.

  ## Options

  * `:time_bits` - Time prefix bits (default: 12). Set to 0 for no time prefix. ⚠️ Cannot be changed after creation.
  * `:time_offset` - Base epoch in Unix seconds (default: 0). ⚠️ Cannot be changed after creation.
  * `:time_bucket` - Time bucket size in seconds (default: 86400 = 1 day). ⚠️ Cannot be changed after creation.
  * `:encrypt_time` - Whether to encrypt time_bits with feistel cipher (default: false). When true, time_bits must be even. ⚠️ Cannot be changed after creation.
  * `:data_bits` - Data cipher bits (default: 40, must be even). ⚠️ Cannot be changed after creation.
  * `:key` - Encryption key (0 to 2^31-1). Auto-generated if not provided. ⚠️ Cannot be changed after creation.
  * `:rounds` - Number of Feistel rounds (default: 16, min: 1, max: 32). ⚠️ Cannot be changed after creation.
  * `:functions_prefix` - Schema where cipher functions are located (default: "public"). ⚠️ Cannot be changed after creation.

  ## Examples

      FeistelCipher.up_for_trigger("public", "posts", "seq", "id")

      FeistelCipher.up_for_trigger("public", "posts", "seq", "id",
        time_bits: 8, time_offset: 1735689600, time_bucket: 3600, data_bits: 32)

      FeistelCipher.up_for_trigger("public", "posts", "seq", "id",
        time_bits: 0)

  """
  @spec up_for_trigger(String.t(), String.t(), String.t(), String.t(), keyword()) :: String.t()
  def up_for_trigger(prefix, table, from, to, opts \\ []) when is_list(opts) do
    time_bits = Keyword.get(opts, :time_bits, 12)
    encrypt_time = Keyword.get(opts, :encrypt_time, false)

    unless time_bits >= 0 do
      raise ArgumentError, "time_bits must be non-negative, got: #{time_bits}"
    end

    if encrypt_time and rem(time_bits, 2) != 0 do
      raise ArgumentError,
            "time_bits must be an even number when encrypt_time is true, got: #{time_bits}"
    end

    time_offset = Keyword.get(opts, :time_offset, 0)

    time_bucket = Keyword.get(opts, :time_bucket, 86400)

    unless time_bucket > 0 do
      raise ArgumentError, "time_bucket must be positive, got: #{time_bucket}"
    end

    data_bits = Keyword.get(opts, :data_bits, 40)

    unless rem(data_bits, 2) == 0 do
      raise ArgumentError, "data_bits must be an even number, got: #{data_bits}"
    end

    unless data_bits >= 2 do
      raise ArgumentError, "data_bits must be at least 2, got: #{data_bits}"
    end

    unless time_bits + data_bits <= 62 do
      raise ArgumentError,
            "time_bits + data_bits must be <= 62, got: #{time_bits} + #{data_bits} = #{time_bits + data_bits}"
    end

    rounds = Keyword.get(opts, :rounds, 16)

    unless rounds >= 1 and rounds <= 32 do
      raise ArgumentError, "rounds must be between 1 and 32, got: #{rounds}"
    end

    key = Keyword.get(opts, :key) || generate_key(prefix, table, from, to)
    validate_key!(key, "key")

    functions_prefix = Keyword.get(opts, :functions_prefix, "public")
    encrypt_time_int = if encrypt_time, do: 1, else: 0

    """
    CREATE TRIGGER #{trigger_name(table, from, to)}
      BEFORE INSERT OR UPDATE
      ON #{prefix}.#{table}
      FOR EACH ROW
      EXECUTE PROCEDURE #{functions_prefix}.feistel_column_trigger('#{from}', '#{to}', #{time_bits}, #{time_offset}, #{time_bucket}, #{encrypt_time_int}, #{data_bits}, #{key}, #{rounds});
    """
  end

  @doc """
  Returns SQL to drop a trigger. **DANGEROUS OPERATION**.

  The generated SQL includes a safety guard that prevents execution by default.
  You must manually remove the `RAISE EXCEPTION` block after understanding the risks.

  For legitimate use cases (like column rename), use `force_down_for_trigger/4` instead.

  ## Example

      FeistelCipher.down_for_trigger("public", "posts", "seq", "id")

  """
  @spec down_for_trigger(String.t(), String.t(), String.t(), String.t()) :: String.t()
  def down_for_trigger(prefix, table, from, to) do
    """
    DO $$
    BEGIN
      RAISE EXCEPTION 'down_for_trigger: trigger deletion prevented. This may break the #{from} -> #{to} encryption for table #{prefix}.#{table}. Use force_down_for_trigger/4 if this is intentional (e.g., column rename). See documentation for details.';
    END
    $$;

    DROP TRIGGER #{trigger_name(table, from, to)} ON #{prefix}.#{table};
    """
  end

  @doc """
  Returns SQL to drop a trigger, bypassing the safety guard.

  Use this when you need to drop and recreate a trigger (e.g., column rename).

  ## When You Need to Drop and Recreate a Trigger

  Common scenarios requiring trigger recreation:
  - **Column rename**: Renaming `seq` to `sequence` or `id` to `external_id`
  - **Table rename**: Renaming `posts` to `articles`
  - **Schema change**: Moving table to a different schema

  ## ⚠️ Compatibility Warning

  If recreating the trigger, you MUST use the exact same encryption parameters:
  - **time_bits**, **time_offset**, **time_bucket**, **encrypt_time**: Same time configuration
  - **data_bits**: Same data bit size (e.g., 40)
  - **key**: Same encryption key
  - **rounds**: Same number of rounds (e.g., 16)
  - **functions_prefix**: Same schema where cipher functions reside (e.g., "public")

  If ANY of these parameters change, the 1:1 mapping breaks:
  - **INSERT**: New records encrypt to different `id` values, causing primary key collisions
  - **UPDATE**: Trigger detects `id` mismatch and raises exception, preventing all updates
  - Existing encrypted `id` values become inconsistent with their `seq` values

  **Safe scenarios**:
  - All parameters match the original values (safe to rename columns/tables)
  - Empty table with no existing encrypted data (safe to use different parameters)

  **Finding original parameters**: Check your migration file where the trigger was created.
  Look for the `up_for_trigger/5` call and its options.
  For auto-generated keys, use `generate_key/4` with the original prefix, table, source, and target column names.

  ## Examples

      # Example: Column rename (seq -> sequence, id -> external_id)
      def change do
        # 1. Drop the old trigger
        execute FeistelCipher.force_down_for_trigger("public", "posts", "seq", "id")

        # 2. Rename columns
        rename table(:posts), :seq, to: :sequence
        rename table(:posts), :id, to: :external_id

        # 3. Recreate trigger with SAME encryption parameters
        # IMPORTANT: Generate key using OLD column names (seq, id)
        old_key = FeistelCipher.generate_key("public", "posts", "seq", "id")

        execute FeistelCipher.up_for_trigger("public", "posts", "sequence", "external_id",
          time_bits: 12,               # Must match original
          time_offset: 1_735_689_600,  # Must match original
          time_bucket: 3600,           # Must match original
          data_bits: 40,               # Must match original
          key: old_key,                # Key from OLD column names
          rounds: 16,                  # Must match original
          functions_prefix: "public"   # Must match original
        )
      end

  """
  @spec force_down_for_trigger(String.t(), String.t(), String.t(), String.t()) :: String.t()
  def force_down_for_trigger(prefix, table, from, to) do
    "DROP TRIGGER #{trigger_name(table, from, to)} ON #{prefix}.#{table};"
  end

  @doc """
  Generates a deterministic encryption key based on table/column information.

  Uses SHA-512 hash to derive a 31-bit key (valid range: 0 to 2^31-1).
  Same parameters always generate the same key, ensuring consistency across deployments.

  This is useful when recreating triggers (e.g., column rename) to maintain the same encryption key.

  ## Examples

      # Get the key used by the original trigger
      key = FeistelCipher.generate_key("public", "posts", "seq", "id")

      # Use it when recreating with new column names
      FeistelCipher.up_for_trigger("public", "posts", "sequence", "external_id", key: key)

  """
  @spec generate_key(String.t(), String.t(), String.t(), String.t()) :: non_neg_integer()
  def generate_key(prefix, table, from, to) do
    <<key::31, _::481>> = :crypto.hash(:sha512, "#{prefix}_#{table}_#{from}_#{to}")
    key
  end

  defp trigger_name(table, from, to) do
    "#{table}_encrypt_#{from}_to_#{to}_trigger"
  end

  defp validate_key!(key, name) do
    max_key = Bitwise.bsl(1, 31) - 1

    unless key >= 0 and key <= max_key do
      raise ArgumentError,
            "#{name} must be between 0 and 2^31-1 (0..#{max_key}), got: #{key}"
    end
  end
end
